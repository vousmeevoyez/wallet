"""
    Transaction Products
    _________________
"""
# pylint: disable=no-self-use
# pylint: disable=import-error
# pylint: disable=bad-whitespace
# pylint: disable=invalid-name
# pylint: disable=no-name-in-module
# pylint: disable=no-member
import pytz
from celery import chain
from abc import ABC
from datetime import datetime, timedelta

from flask import current_app

from sqlalchemy.exc import IntegrityError
from app.api import db, scheduler

# models
from app.api.models import TransactionType, TransactionNote, PaymentPlan

# task
from task.transaction.tasks import TransactionTask
from task.bank.tasks import BankTask
from task.payment.tasks import PaymentTask
from task.utility.tasks import UtilityTask


class TransactionError(Exception):
    """ raised when something occured on creating transaction """

    def __init__(self, original_exception):
        super().__init__(original_exception)
        self.original_exception = original_exception


class AbstractTransaction(ABC):
    """ abstract transaction class """

    def __init__(self):
        self.transaction = None

    def load(self, transaction):
        self.transaction = transaction

    @staticmethod
    def generate_notes(flag, amount):
        """ autogenerated transaction notes based from flag  """
        transfer_notes = TransactionNote.query.filter_by(key=flag).first()
        notes = transfer_notes.notes.format(str(amount))
        return notes

    # end def

    def create(self, flag):
        # fetch transaction type from db
        type_ = TransactionType.query.filter_by(key=flag).first()

        transfer_notes = self.transaction.notes
        if transfer_notes is None:
            transfer_notes = self.generate_notes(flag, self.transaction.amount)
        # end if

        # debit (-) we increase balance
        transaction = self.transaction
        transaction.transaction_type_id = type_.id
        transaction.notes = transfer_notes

        try:
            db.session.add(transaction)
            db.session.commit()
        except IntegrityError as error:
            db.session.rollback()
            raise TransactionError(error)
        # end try

        # should send queue here
        result = chain(
            TransactionTask()
            .transfer.s(self.transaction.payment.id)
            .set(queue="transaction"),
            UtilityTask().push_notification.s().set(queue="utility"),
        ).apply_async()

        return transaction

    # end def


class DebitTransaction(AbstractTransaction):
    """ Base class that represent transaction that deduct balance """

    def create(self, flag):
        result = super().create(flag)
        self.post_create(flag)
        return result

    # end def

    def post_create(self, flag):
        """ should trigger something when after debit transaction created """
        pass

    # end def


# end class


class CreditTransaction(AbstractTransaction):
    """ Base class that represent transaction that add balance """

    def create(self, flag):
        result = super().create(flag)
        self.post_create(flag)
        return result

    # end def

    def post_create(self, flag):
        """ should trigger something when after credit transaction created """
        pass

    # end def


# end class


class TransferTransaction(DebitTransaction):
    """ implementation class of transfer between user """

    pass


class PayrollTransaction(DebitTransaction):
    """ implementation class of sending payroll to user """

    pass


class WithdrawTransaction(DebitTransaction):
    """ implementation class of withdraw money from wallet """

    pass


class BankTransferTransaction(DebitTransaction):
    """ implementation class of transfer money to bank """

    def post_create(self, flag):
        result = BankTask().bank_transfer.apply_async(
            args=[self.transaction.payment.id], queue="bank"
        )


class TransferFeeTransaction(DebitTransaction):
    """ implementation class of transfer fee """

    pass


class AutoDebitTransaction(BankTransferTransaction):
    """ implementation class of auto debit transaction """

    pass


class AutoPayTransaction(BankTransferTransaction):
    """ implementation class of auto pay transaction """

    pass


class CreditRefundTransaction(DebitTransaction):
    """ implementation class of refund credit transaction """

    pass


class TopUpTransaction(CreditTransaction):
    """ implementation class of top up to wallet """
    pass


class CashbackTransaction(CreditTransaction):
    """ implementation class of cashback transaction to wallet """
    pass


class ReceiveTransferTransaction(CreditTransaction):
    """ implementation class of receive money to wallet """

    pass


class ReceivePayrollTransaction(CreditTransaction):
    """ implementation class of receive payroll to wallet """

    def post_create(self, flag):
        """ should decide trigger auto debit or auto pay here after successfully receive the money """
        payroll_amount = self.transaction.amount

        response = []

        plans = PaymentPlan.check_payments(self.transaction.wallet)
        current_app.logger.info("no of plans {}".format(plans))
        for plan in plans:
            # make sure today is the due date to able deduct it
            indo_time = pytz.timezone("Asia/Jakarta")

            due_date = plan.due_date

            payroll_date = datetime.utcnow()
            differences = payroll_date - due_date

            total_amount, plans = PaymentPlan.total(plan)

            # if there's no day differences and payroll is bigger than payment
            if differences.days == 0 and payroll_amount >= total_amount:
                # bank account
                current_app.logger.info("should trigger AUTO_PAY")
                PaymentTask.background_transfer.apply_async(
                    args=[plan.id, "AUTO_PAY"], queue="payment"
                )
                current_app.logger.info("payroll_date : {}".format(payroll_date))
                current_app.logger.info("due_date : {}".format(due_date))
                current_app.logger.info("differences : {}".format(differences.days))
                current_app.logger.info("should trigger AUTO_PAY")
                response.append({"message": "AUTO_PAY"})
            else:
                current_app.logger.info("payroll_date : {}".format(payroll_date))
                current_app.logger.info("due_date : {}".format(due_date))
                current_app.logger.info("differences : {}".format(differences.days))
                current_app.logger.info("should trigger AUTO_DEBIT")
                # should switch to AUTO_DEBIT
                # if its early payroll should trigger auto debit on due date
                if differences.days < 0:
                    due_date = plan.due_date
                # if its payroll == due date but insufficient payroll, should
                # trigger auto debit on the next minutese
                elif differences.days == 0:
                    due_date = payroll_date + timedelta(minutes=1)
                elif differences.days > 0:
                    due_date = None
                # end if

                if due_date is not None:
                    job = scheduler.add_job(
                        lambda: PaymentTask.background_transfer.apply_async(
                            args=[plan.id], queue="payment"
                        ),
                        trigger="date",
                        next_run_time=due_date.replace(tzinfo=indo_time),
                    )
                    response.append({"message": "AUTO_DEBIT"})
                # end if
            # end if
        # end if
        return response


class DebitRefundTransaction(CreditTransaction):
    """ implementation class of refund debit transaction """

    pass
